import * as i0 from '@angular/core';
import { signal, PLATFORM_ID, Input, ViewChild, Inject, ChangeDetectionStrategy, Component } from '@angular/core';
import * as i1 from '@angular/common';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { Renderer, Camera, Triangle, Vec3, Program, Mesh, Transform } from 'ogl';

class NgxLavaLampComponent {
    platformId;
    containerRef;
    styleClass;
    set color(val) {
        this._color = val;
        this.resetScene();
    }
    set speed(val) {
        this._speed = val;
        this.resetScene();
    }
    set enableMouseInteraction(val) {
        this._enableMouseInteraction = val;
        this.resetScene();
    }
    set hoverSmoothness(val) {
        this._hoverSmoothness = val;
        this.resetScene();
    }
    set animationSize(val) {
        this._animationSize = val;
        this.resetScene();
    }
    set ballCount(val) {
        this._ballCount = val;
        this.resetScene();
    }
    set clumpFactor(val) {
        this._clumpFactor = val;
        this.resetScene();
    }
    set cursorBallSize(val) {
        this._cursorBallSize = val;
        this.resetScene();
    }
    set cursorBallColor(val) {
        this._cursorBallColor = val;
        this.resetScene();
    }
    _color = '#ffffff';
    _speed = 0.2;
    _enableMouseInteraction = false;
    _hoverSmoothness = 0.05;
    _animationSize = 30;
    _ballCount = 15;
    _clumpFactor = 1;
    _cursorBallSize = 3;
    _cursorBallColor = '#ffffff';
    initialized = false;
    running = false;
    animationFrameId = null;
    intersectionObserver;
    isInView = signal(false);
    renderer;
    gl;
    program;
    metaBallsUniform = [];
    mesh;
    scene;
    camera;
    ballParams = [];
    mouseBallPos = { x: 0, y: 0 };
    pointerInside = false;
    pointerX = 0;
    pointerY = 0;
    resizeListener;
    pointerMoveListener;
    pointerEnterListener;
    pointerLeaveListener;
    constructor(platformId) {
        this.platformId = platformId;
    }
    ngAfterViewInit() {
        if (!isPlatformBrowser(this.platformId))
            return;
        this.intersectionObserver = new IntersectionObserver(([entry]) => {
            const wasInView = this.isInView();
            this.isInView.set(entry.isIntersecting);
            if (!wasInView && this.isInView()) {
                this.running = true;
                this.initLavaLamp();
                this.animate();
            }
            if (wasInView && !this.isInView()) {
                this.running = false;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }
        });
        this.intersectionObserver.observe(this.containerRef.nativeElement);
    }
    ngOnDestroy() {
        this.running = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        if (this.intersectionObserver)
            this.intersectionObserver.disconnect();
        this.cleanupOGL();
    }
    cleanupOGL() {
        try {
            if (this.gl?.canvas && this.containerRef.nativeElement.contains(this.gl.canvas)) {
                this.containerRef.nativeElement.removeChild(this.gl.canvas);
            }
            this.gl?.getExtension('WEBGL_lose_context')?.loseContext();
        }
        catch {
        }
        if (this.resizeListener)
            window.removeEventListener('resize', this.resizeListener);
        if (this.pointerMoveListener)
            this.containerRef.nativeElement.removeEventListener('pointermove', this.pointerMoveListener);
        if (this.pointerEnterListener)
            this.containerRef.nativeElement.removeEventListener('pointerenter', this.pointerEnterListener);
        if (this.pointerLeaveListener)
            this.containerRef.nativeElement.removeEventListener('pointerleave', this.pointerLeaveListener);
        this.resizeListener = undefined;
        this.pointerMoveListener = undefined;
        this.pointerEnterListener = undefined;
        this.pointerLeaveListener = undefined;
        this.initialized = false;
    }
    // If any @Input changes, completely reset the OGL scene:
    resetScene() {
        if (!this.initialized)
            return;
        this.running = false;
        if (this.animationFrameId)
            cancelAnimationFrame(this.animationFrameId);
        this.cleanupOGL();
        this.initialized = false;
        if (this.isInView()) {
            this.running = true;
            this.initLavaLamp();
            this.animate();
        }
    }
    parseHexColor(hex) {
        const c = hex.replace('#', '');
        const r = parseInt(c.substring(0, 2), 16) / 255;
        const g = parseInt(c.substring(2, 4), 16) / 255;
        const b = parseInt(c.substring(4, 6), 16) / 255;
        return [r, g, b];
    }
    fract(x) {
        return x - Math.floor(x);
    }
    hash31(p) {
        let r = [p * 0.1031, p * 0.1030, p * 0.0973].map(this.fract);
        const r_yzx = [r[1], r[2], r[0]];
        const dotVal = r[0] * (r_yzx[0] + 33.33) +
            r[1] * (r_yzx[1] + 33.33) +
            r[2] * (r_yzx[2] + 33.33);
        for (let i = 0; i < 3; i++) {
            r[i] = this.fract(r[i] + dotVal);
        }
        return r;
    }
    hash33(v) {
        let p = [v[0] * 0.1031, v[1] * 0.1030, v[2] * 0.0973].map(this.fract);
        const p_yxz = [p[1], p[0], p[2]];
        const dotVal = p[0] * (p_yxz[0] + 33.33) +
            p[1] * (p_yxz[1] + 33.33) +
            p[2] * (p_yxz[2] + 33.33);
        for (let i = 0; i < 3; i++) {
            p[i] = this.fract(p[i] + dotVal);
        }
        const p_xxy = [p[0], p[0], p[1]];
        const p_yxx = [p[1], p[0], p[0]];
        const p_zyx = [p[2], p[1], p[0]];
        const result = [];
        for (let i = 0; i < 3; i++) {
            result[i] = this.fract((p_xxy[i] + p_yxx[i]) * p_zyx[i]);
        }
        return result;
    }
    initLavaLamp() {
        this.cleanupOGL(); // Just in case
        this.initialized = false;
        const container = this.containerRef.nativeElement;
        if (!container)
            return;
        const dpr = 1;
        this.renderer = new Renderer({ dpr, alpha: true, premultipliedAlpha: false });
        this.gl = this.renderer.gl;
        this.gl.clearColor(0, 0, 0, 0);
        container.appendChild(this.gl.canvas);
        this.camera = new Camera(this.gl, {
            left: -1, right: 1, top: 1, bottom: -1, near: 0.1, far: 10,
        });
        this.camera.position.z = 1;
        const geometry = new Triangle(this.gl);
        const [r1, g1, b1] = this.parseHexColor(this._color);
        const [r2, g2, b2] = this.parseHexColor(this._cursorBallColor);
        this.metaBallsUniform = [];
        for (let i = 0; i < 50; i++)
            this.metaBallsUniform.push(new Vec3(0, 0, 0));
        const vertex = `#version 300 es
    precision highp float;
    layout(location = 0) in vec2 position;
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
    }`;
        const fragment = `#version 300 es
    precision highp float;
    uniform vec3 iResolution;
    uniform float iTime;
    uniform vec3 iMouse;
    uniform vec3 iColor;
    uniform vec3 iCursorColor;
    uniform float iAnimationSize;
    uniform int iBallCount;
    uniform float iCursorBallSize;
    uniform vec3 iMetaBalls[50];
    uniform float iClumpFactor;
    uniform bool enableTransparency;
    out vec4 outColor;
    const float PI = 3.14159265359;
    float getMetaBallValue(vec2 c, float r, vec2 p) {
      vec2 d = p - c;
      float dist2 = dot(d, d);
      return (r * r) / dist2;
    }
    void main() {
      vec2 fc = gl_FragCoord.xy;
      float scale = iAnimationSize / iResolution.y;
      vec2 coord = (fc - iResolution.xy * 0.5) * scale;
      vec2 mouseW = (iMouse.xy - iResolution.xy * 0.5) * scale;
      float m1 = 0.0;
      for (int i = 0; i < 50; i++) {
        if (i >= iBallCount) break;
        m1 += getMetaBallValue(iMetaBalls[i].xy, iMetaBalls[i].z, coord);
      }
      float m2 = getMetaBallValue(mouseW, iCursorBallSize, coord);
      float total = m1 + m2;
      float f = smoothstep(-1.0, 1.0, (total - 1.3) / min(1.0, fwidth(total)));
      vec3 cFinal = vec3(0.0);
      if (total > 0.0) {
        float alpha1 = m1 / total;
        float alpha2 = m2 / total;
        cFinal = iColor * alpha1 + iCursorColor * alpha2;
      }
      outColor = vec4(cFinal * f, enableTransparency ? f : 1.0);
    }`;
        this.program = new Program(this.gl, {
            vertex,
            fragment,
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new Vec3(0, 0, 0) },
                iMouse: { value: new Vec3(0, 0, 0) },
                iColor: { value: new Vec3(r1, g1, b1) },
                iCursorColor: { value: new Vec3(r2, g2, b2) },
                iAnimationSize: { value: this._animationSize },
                iBallCount: { value: this._ballCount },
                iCursorBallSize: { value: this._cursorBallSize },
                iMetaBalls: { value: this.metaBallsUniform },
                iClumpFactor: { value: this._clumpFactor },
                enableTransparency: { value: true },
            },
        });
        this.mesh = new Mesh(this.gl, { geometry, program: this.program });
        this.scene = new Transform();
        this.mesh.setParent(this.scene);
        // Ball params
        const maxBalls = 50;
        const effectiveBallCount = Math.min(this._ballCount, maxBalls);
        this.ballParams = [];
        for (let i = 0; i < effectiveBallCount; i++) {
            const idx = i + 1;
            const h1 = this.hash31(idx);
            const st = h1[0] * (2 * Math.PI);
            const dtFactor = 0.1 * Math.PI + h1[1] * (0.4 * Math.PI - 0.1 * Math.PI);
            const baseScale = 5.0 + h1[1] * (10.0 - 5.0);
            const h2 = this.hash33(h1);
            const toggle = Math.floor(h2[0] * 2.0);
            const radiusVal = 0.5 + h2[2] * (2.0 - 0.5);
            this.ballParams.push({ st, dtFactor, baseScale, toggle, radius: radiusVal });
        }
        this.mouseBallPos = { x: 0, y: 0 };
        this.pointerInside = false;
        this.pointerX = 0;
        this.pointerY = 0;
        // ---- Event listeners
        this.resizeListener = () => {
            const width = container.clientWidth;
            const height = container.clientHeight;
            this.renderer?.setSize(width * dpr, height * dpr);
            if (this.gl) {
                this.gl.canvas.style.width = width + 'px';
                this.gl.canvas.style.height = height + 'px';
                this.program?.uniforms['iResolution'].value.set(this.gl.canvas.width, this.gl.canvas.height, 0);
            }
        };
        window.addEventListener('resize', this.resizeListener);
        this.resizeListener();
        this.pointerMoveListener = (e) => {
            if (!this._enableMouseInteraction)
                return;
            const rect = container.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;
            this.pointerX = (px / rect.width) * (this.gl?.canvas.width || 1);
            this.pointerY = (1 - py / rect.height) * (this.gl?.canvas.height || 1);
        };
        this.pointerEnterListener = () => {
            if (!this._enableMouseInteraction)
                return;
            this.pointerInside = true;
        };
        this.pointerLeaveListener = () => {
            if (!this._enableMouseInteraction)
                return;
            this.pointerInside = false;
        };
        container.addEventListener('pointermove', this.pointerMoveListener);
        container.addEventListener('pointerenter', this.pointerEnterListener);
        container.addEventListener('pointerleave', this.pointerLeaveListener);
        this.initialized = true;
    }
    animate = () => {
        if (!this.running)
            return;
        const startTime = performance.now();
        const loop = (t) => {
            if (!this.running)
                return;
            this.animationFrameId = requestAnimationFrame(loop);
            const elapsed = (t - startTime) * 0.001;
            this.program.uniforms['iTime'].value = elapsed;
            const effectiveBallCount = Math.min(this._ballCount, 50);
            for (let i = 0; i < effectiveBallCount; i++) {
                const p = this.ballParams[i];
                const dt = elapsed * this._speed * p.dtFactor;
                const th = p.st + dt;
                const x = Math.cos(th);
                const y = Math.sin(th + dt * p.toggle);
                const posX = x * p.baseScale * this._clumpFactor;
                const posY = y * p.baseScale * this._clumpFactor;
                this.metaBallsUniform[i].set(posX, posY, p.radius);
            }
            let targetX, targetY;
            if (this.pointerInside) {
                targetX = this.pointerX;
                targetY = this.pointerY;
            }
            else {
                const cx = this.gl.canvas.width * 0.5;
                const cy = this.gl.canvas.height * 0.5;
                const rx = this.gl.canvas.width * 0.15;
                const ry = this.gl.canvas.height * 0.15;
                targetX = cx + Math.cos(elapsed * this._speed) * rx;
                targetY = cy + Math.sin(elapsed * this._speed) * ry;
            }
            this.mouseBallPos.x += (targetX - this.mouseBallPos.x) * this._hoverSmoothness;
            this.mouseBallPos.y += (targetY - this.mouseBallPos.y) * this._hoverSmoothness;
            this.program.uniforms['iMouse'].value.set(this.mouseBallPos.x, this.mouseBallPos.y, 0);
            this.renderer.render({ scene: this.scene, camera: this.camera });
        };
        this.animationFrameId = requestAnimationFrame(loop);
    };
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxLavaLampComponent, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "20.0.3", type: NgxLavaLampComponent, isStandalone: true, selector: "om-lava-lamp", inputs: { styleClass: "styleClass", color: "color", speed: "speed", enableMouseInteraction: "enableMouseInteraction", hoverSmoothness: "hoverSmoothness", animationSize: "animationSize", ballCount: "ballCount", clumpFactor: "clumpFactor", cursorBallSize: "cursorBallSize", cursorBallColor: "cursorBallColor" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["OmLavaLamp"], descendants: true }], ngImport: i0, template: "<div class=\"om-lava-lamp\" [ngClass]=\"styleClass\" #OmLavaLamp></div>\n", styles: [".om-lava-lamp{position:relative;width:100%;height:100%}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.3", ngImport: i0, type: NgxLavaLampComponent, decorators: [{
            type: Component,
            args: [{ selector: 'om-lava-lamp', standalone: true, imports: [CommonModule], changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"om-lava-lamp\" [ngClass]=\"styleClass\" #OmLavaLamp></div>\n", styles: [".om-lava-lamp{position:relative;width:100%;height:100%}\n"] }]
        }], ctorParameters: () => [{ type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }], propDecorators: { containerRef: [{
                type: ViewChild,
                args: ['OmLavaLamp']
            }], styleClass: [{
                type: Input,
                args: ['styleClass']
            }], color: [{
                type: Input
            }], speed: [{
                type: Input
            }], enableMouseInteraction: [{
                type: Input
            }], hoverSmoothness: [{
                type: Input
            }], animationSize: [{
                type: Input
            }], ballCount: [{
                type: Input
            }], clumpFactor: [{
                type: Input
            }], cursorBallSize: [{
                type: Input
            }], cursorBallColor: [{
                type: Input
            }] } });

/*
 * Public API Surface of ngx-lava-lamp
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxLavaLampComponent };
//# sourceMappingURL=omnedia-ngx-lava-lamp.mjs.map
