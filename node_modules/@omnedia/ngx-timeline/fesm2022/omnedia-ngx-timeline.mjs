import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { signal, Input, ViewChild, ViewChildren, ChangeDetectionStrategy, Component } from '@angular/core';
import { takeUntil, Subject } from 'rxjs';
import * as i1 from '@angular/platform-browser';

class NgxTimelineComponent {
    sanitizer;
    renderer;
    wrapperRef;
    entriesList;
    timelineBackgroundRef;
    timelineLineRef;
    timelineSvgRef;
    timelinePathRef;
    timelineGradientPathRef;
    orientation = "left";
    styleClass;
    set entriesGap(gap) {
        this.style.set({ ...this.style(), '--om-timeline-entries-gap': gap });
    }
    set entryGap(gap) {
        this.style.set({ ...this.style(), '--om-timeline-entry-gap': gap });
    }
    set titleGap(gap) {
        this.style.set({ ...this.style(), '--om-timeline-entry-title-gap': gap });
    }
    set pathWidth(pathWidth) {
        this.style.set({ ...this.style(), '--om-timeline-path-width': pathWidth });
    }
    set titleMaxWidth(titleMaxWidth) {
        this.style.set({ ...this.style(), '--om-timeline-entry-title-max-width': titleMaxWidth });
    }
    set pathColorValue(pathColor) {
        this.pathColor = pathColor;
        this.style.set({ ...this.style(), '--om-timeline-path-color': pathColor });
    }
    set gradientColors(gradientColors) {
        if (gradientColors.length !== 2) {
            return;
        }
        this.gradientStart = gradientColors[0];
        this.gradientEnd = gradientColors[1];
        this.style.set({ ...this.style(), '--om-timeline-gradient-start': this.gradientStart });
        this.style.set({ ...this.style(), '--om-timeline-gradient-end': this.gradientEnd });
    }
    gradientStart = "#3b82f6";
    gradientEnd = "#7f00ff";
    pathColor = "#e2e8f0";
    set dataValue(data) {
        this.data = data;
        this.addViewEncapsulationTag();
    }
    data = [];
    templateData = signal([]);
    style = signal({});
    ngContentRef;
    scrollableParent = window;
    scrollListener;
    updatePending = false;
    constructor(sanitizer, renderer) {
        this.sanitizer = sanitizer;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.entriesList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            setTimeout(() => {
                this.setHeight();
            }, 10);
        });
        this.getViewEncapsulationTag();
        this.determineScrollContext();
        this.updateTimelineLine();
        window.addEventListener("resize", () => this.setHeight());
    }
    destroy$ = new Subject();
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.removeScrollListener();
        window.removeEventListener("resize", () => this.setHeight());
    }
    getViewEncapsulationTag() {
        const parent = this.wrapperRef.nativeElement.parentElement?.parentElement;
        if (!parent) {
            return;
        }
        const attributes = parent.getAttributeNames();
        const ngContentRef = attributes.find((attr) => attr.includes("_ngcontent-ng"));
        if (!ngContentRef) {
            return;
        }
        this.ngContentRef = ngContentRef;
        this.addViewEncapsulationTag();
    }
    addViewEncapsulationTag() {
        if (!this.data || this.data.length <= 0 || !this.ngContentRef) {
            return;
        }
        const templateData = [];
        this.data.forEach((data) => {
            const title = this.insertAttributeInTags(data.title);
            const content = this.insertAttributeInTags(data.content);
            const templateDataEntry = {
                title: this.sanitizer.bypassSecurityTrustHtml(title),
                content: this.sanitizer.bypassSecurityTrustHtml(content),
            };
            templateData.push(templateDataEntry);
        });
        this.templateData.set(templateData);
    }
    insertAttributeInTags(inputString) {
        return inputString.replace(/<(\w+)/g, `<$1 ${this.ngContentRef}`);
    }
    determineScrollContext() {
        let parent = this.wrapperRef.nativeElement.parentElement;
        while (parent && parent !== document.body) {
            const overflowY = window.getComputedStyle(parent).overflowY;
            if (overflowY === "auto" || overflowY === "scroll") {
                this.scrollableParent = parent;
                break;
            }
            parent = parent.parentElement;
        }
        this.setupScrollListener();
    }
    setupScrollListener() {
        this.scrollListener = this.renderer.listen(this.scrollableParent, "scroll", () => this.updateTimelineLine());
    }
    removeScrollListener() {
        if (this.scrollListener) {
            this.scrollListener();
        }
    }
    setHeight() {
        if (this.orientation != "switch") {
            const rect = this.wrapperRef.nativeElement.getBoundingClientRect();
            this.timelineBackgroundRef.nativeElement.style.height = `${rect.height}px`;
        }
        else {
            this.updateSvgPath();
        }
        this.updateTimelineLine();
    }
    updateTimelineLine() {
        if (this.updatePending)
            return;
        this.updatePending = true;
        requestAnimationFrame(() => {
            this.updatePending = false;
            const rect = this.wrapperRef.nativeElement.getBoundingClientRect();
            const scrollHeight = this.scrollableParent === window
                ? window.innerHeight
                : this.scrollableParent.clientHeight;
            const topPosition = this.scrollableParent === window
                ? rect.top * -1
                : this.scrollableParent.scrollTop;
            if (this.orientation === "switch") {
                let progress = topPosition / (rect.height - scrollHeight);
                if (progress >= 1) {
                    progress = 1;
                }
                else if (progress <= 0) {
                    progress = 0;
                }
                const length = this.timelineGradientPathRef.nativeElement.getTotalLength();
                this.timelineGradientPathRef.nativeElement.style.strokeDasharray = `${length}`;
                this.timelineGradientPathRef.nativeElement.style.strokeDashoffset = `${length * (1 - progress)}`;
                return;
            }
            let progress = topPosition / rect.height;
            if (topPosition >= rect.height || progress >= 1) {
                this.timelineLineRef.nativeElement.style.height = `${rect.height}px`;
                return;
            }
            this.timelineLineRef.nativeElement.style.height = `${progress * rect.height + scrollHeight * 0.5}px`;
        });
    }
    updateSvgPath() {
        const path = this.calculateSvgPath();
        const wrapperRect = this.wrapperRef.nativeElement.getBoundingClientRect();
        this.timelineSvgRef.nativeElement.setAttribute("width", `${wrapperRect.width - 20}`);
        this.timelineSvgRef.nativeElement.setAttribute("height", `${wrapperRect.height}`);
        this.timelinePathRef.nativeElement.setAttribute("d", path);
        this.timelineGradientPathRef.nativeElement.setAttribute("d", path);
    }
    calculateSvgPath() {
        const entries = this.entriesList.toArray();
        let path = "";
        // Adjust the control point extensions based on screen size
        const isMobile = window.innerWidth <= 1000;
        const curveExtension = isMobile ? 200 : 500; // Shorter curve extensions on mobile
        for (let i = 0; i < entries.length; i++) {
            const entryRect = entries[i].nativeElement.getBoundingClientRect();
            const wrapperRect = this.wrapperRef.nativeElement.getBoundingClientRect();
            const startX = i % 2 === 0 ? 0 : wrapperRect.width - 40; // Start from 0px or the right side
            const endX = i % 2 === 0 ? wrapperRect.width - 40 : 0; // End at the opposite side
            const startY = entryRect.top - wrapperRect.top;
            const endY = entryRect.bottom - wrapperRect.top;
            if (i === 0) {
                // Move to the starting point of the first entry, by 10rem (100px) above it
                path += `M${startX},${startY - 160}`;
            }
            // Extend the straight line slightly before starting the curve
            const extendedY = endY + 10;
            // Draw the extended straight line
            path += ` L${startX},${extendedY}`;
            if (i < entries.length - 1) {
                const nextEntryRect = entries[i + 1].nativeElement.getBoundingClientRect();
                const nextStartY = nextEntryRect.top - wrapperRect.top;
                const controlPointY1 = extendedY + curveExtension; // Adjusted control points for mobile
                const controlPointY2 = nextStartY - curveExtension;
                // S-shaped curve with adjusted control points for smoother transition on mobile
                path += ` C${startX},${controlPointY1} ${endX},${controlPointY2} ${endX},${nextStartY}`;
            }
            else {
                // End the path with a straight line at the last entry, but extend it by 10rem (160px)
                path += ` L${startX},${endY + 160}`;
            }
        }
        return path;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.2", ngImport: i0, type: NgxTimelineComponent, deps: [{ token: i1.DomSanitizer }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "20.0.2", type: NgxTimelineComponent, isStandalone: true, selector: "om-timeline", inputs: { orientation: "orientation", styleClass: "styleClass", entriesGap: "entriesGap", entryGap: "entryGap", titleGap: "titleGap", pathWidth: "pathWidth", titleMaxWidth: "titleMaxWidth", pathColorValue: ["pathColor", "pathColorValue"], gradientColors: "gradientColors", dataValue: ["data", "dataValue"] }, viewQueries: [{ propertyName: "wrapperRef", first: true, predicate: ["wrapper"], descendants: true }, { propertyName: "timelineBackgroundRef", first: true, predicate: ["timelineBackground"], descendants: true }, { propertyName: "timelineLineRef", first: true, predicate: ["timelineLine"], descendants: true }, { propertyName: "timelineSvgRef", first: true, predicate: ["timelineSvg"], descendants: true }, { propertyName: "timelinePathRef", first: true, predicate: ["timelinePath"], descendants: true }, { propertyName: "timelineGradientPathRef", first: true, predicate: ["timelineGradientPath"], descendants: true }, { propertyName: "entriesList", predicate: ["entries"], descendants: true }], ngImport: i0, template: "<div\r\n  class=\"om-timeline\"\r\n  [ngStyle]=\"style()\"\r\n  [ngClass]=\"styleClass\"\r\n  [class.left]=\"orientation === 'left'\"\r\n  [class.right]=\"orientation === 'right'\"\r\n  [class.switch]=\"orientation === 'switch'\"\r\n  #wrapper\r\n>\r\n  <div class=\"om-timeline-entries\">\r\n    @for (item of templateData(); track $index) {\r\n      <div\r\n        class=\"om-timeline-entry\"\r\n        [ngClass]=\"{\r\n        'right-side':\r\n          orientation === 'right' || (orientation === 'switch' && $index % 2 !== 0),\r\n        'left-side':\r\n          orientation === 'left' || (orientation === 'switch' && $index % 2 === 0)\r\n      }\"\r\n        #entries\r\n      >\r\n        <div class=\"om-timeline-entry-header\">\r\n          <div class=\"om-timeline-circle\">\r\n            <div class=\"om-timeline-inner-circle\"></div>\r\n          </div>\r\n          <div class=\"om-timeline-entry-title\" [innerHTML]=\"item.title\"></div>\r\n        </div>\r\n        <div class=\"om-timeline-entry-content\" [innerHTML]=\"item.content\"></div>\r\n      </div>\r\n    }\r\n\r\n    <div class=\"om-timeline-line-wrapper\">\r\n      <svg\r\n        #timelineSvg\r\n        class=\"om-timeline-svg\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        [class.d-none]=\"orientation !== 'switch'\"\r\n      >\r\n        <defs>\r\n          <linearGradient id=\"gradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n            <stop\r\n              offset=\"0%\"\r\n              style=\"stop-color: transparent; stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"10%\"\r\n              [style.stop-color]=\"gradientEnd\"\r\n              style=\"stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"90%\"\r\n              [style.stop-color]=\"gradientStart\"\r\n              style=\"stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"100%\"\r\n              style=\"stop-color: transparent; stop-opacity: 1\"\r\n            />\r\n          </linearGradient>\r\n          <linearGradient id=\"gradientBg\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n            <stop\r\n              offset=\"0%\"\r\n              style=\"stop-color: transparent; stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"10%\"\r\n              [style.stop-color]=\"pathColor\"\r\n              style=\"stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"90%\"\r\n              [style.stop-color]=\"pathColor\"\r\n              style=\"stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"100%\"\r\n              style=\"stop-color: transparent; stop-opacity: 1\"\r\n            />\r\n          </linearGradient>\r\n        </defs>\r\n        <path #timelinePath class=\"om-timeline-path\"></path>\r\n        <path #timelineGradientPath class=\"om-timeline-gradient-path\"></path>\r\n      </svg>\r\n\r\n      <div\r\n        class=\"om-timeline-line\"\r\n        #timelineBackground\r\n        [class.d-none]=\"orientation === 'switch'\"\r\n      >\r\n        <div #timelineLine class=\"om-timeline-motion\"></div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".om-timeline{--om-timeline-entries-gap: 5rem;--om-timeline-entry-gap: 4rem;--om-timeline-entry-title-gap: 2rem;--om-timeline-entry-title-max-width: 25rem;--om-timeline-path-width: 2px;--om-timeline-gradient-start: #3b82f6;--om-timeline-gradient-end: #7f00ff;--om-timeline-path-color: #e2e8f0;width:100%}.om-timeline .om-timeline-entries{position:relative;display:flex;flex-direction:column;gap:var(--om-timeline-entries-gap);padding:10rem 0}.om-timeline .om-timeline-entries .om-timeline-entry{display:flex;justify-content:start;padding-top:20px;gap:var(--om-timeline-entry-gap)}.om-timeline.switch>.om-timeline-entries{gap:calc(var(--om-timeline-entries-gap) * 6)}.om-timeline .om-timeline-entry-header{position:sticky;top:10rem;z-index:40;display:flex;align-items:center;align-self:flex-start;gap:var(--om-timeline-entry-title-gap);width:50%;max-width:var(--om-timeline-entry-title-max-width)}.om-timeline .om-timeline-entry-header .om-timeline-circle{height:40px;width:40px;border-radius:50%;background-color:#000;display:flex;align-items:center;justify-content:center;flex-shrink:0}.om-timeline .om-timeline-entry-header .om-timeline-inner-circle{height:16px;width:16px;border-radius:50%;background-color:#262626;border:1px solid rgb(64,64,64)}.om-timeline .om-timeline-entry-content{flex:1}.om-timeline .om-timeline-line-wrapper{position:absolute;top:0;left:20px;pointer-events:none}.om-timeline .om-timeline-line-wrapper .d-none{display:none;height:0;width:0}.om-timeline .om-timeline-line-wrapper .om-timeline-line{width:var(--om-timeline-path-width);background:linear-gradient(to bottom,transparent 0%,#e2e8f0 50%,transparent 100%);-webkit-mask-image:linear-gradient(to bottom,transparent 0%,black 10%,black 90%,transparent 100%);mask-image:linear-gradient(to bottom,transparent 0%,black 10%,black 90%,transparent 100%);overflow:hidden;position:absolute;top:0;left:0;width:2px}.om-timeline .om-timeline-line-wrapper .om-timeline-motion{width:2px;background:linear-gradient(to top,#7f00ff 0%,#3b82f6 50%,transparent 100%);border-radius:50%}.om-timeline.right .om-timeline-entries .om-timeline-entry{flex-direction:row-reverse}.om-timeline.right .om-timeline-entries .om-timeline-entry .om-timeline-entry-header{flex-direction:row-reverse;justify-content:space-between}.om-timeline.right .om-timeline-line-wrapper{left:unset;right:20px}.om-timeline.switch .om-timeline-entries .om-timeline-entry.right-side,.om-timeline.switch .om-timeline-entries .om-timeline-entry.right-side .om-timeline-entry-header{flex-direction:row-reverse}.om-timeline.switch .om-timeline-entries .om-timeline-entry.left-side,.om-timeline.switch .om-timeline-entries .om-timeline-entry.left-side .om-timeline-entry-header{flex-direction:row}.om-timeline.switch .om-timeline-line-wrapper{left:20px}.om-timeline .om-timeline-path{stroke-width:var(--om-timeline-path-width);fill:none;stroke:url(#gradientBg);stroke-linecap:round;stroke-linejoin:round}.om-timeline .om-timeline-gradient-path{stroke-width:var(--om-timeline-path-width);fill:none;stroke:url(#gradient);stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:1000;stroke-dashoffset:1000;transition:stroke-dashoffset .5s ease}@media only screen and (max-width: 1000px){.om-timeline.switch>.om-timeline-entries{gap:calc(var(--om-timeline-entries-gap) * 3)}.om-timeline .om-timeline-entries .om-timeline-entry{position:relative;flex-direction:column!important}.om-timeline .om-timeline-entries .om-timeline-entry .om-timeline-entry-header{position:relative;top:0;max-width:100%;text-align:left}.om-timeline .om-timeline-entries .om-timeline-entry.left-side .om-timeline-entry-content{margin-left:70px}.om-timeline .om-timeline-entries .om-timeline-entry.left-side .om-timeline-entry-header{left:0;margin-right:auto}.om-timeline .om-timeline-entries .om-timeline-entry.right-side .om-timeline-entry-header{right:0;margin-left:auto;justify-content:space-between}.om-timeline .om-timeline-entries .om-timeline-entry.right-side .om-timeline-entry-content{margin-right:70px}}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.2", ngImport: i0, type: NgxTimelineComponent, decorators: [{
            type: Component,
            args: [{ selector: "om-timeline", standalone: true, imports: [CommonModule], changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\r\n  class=\"om-timeline\"\r\n  [ngStyle]=\"style()\"\r\n  [ngClass]=\"styleClass\"\r\n  [class.left]=\"orientation === 'left'\"\r\n  [class.right]=\"orientation === 'right'\"\r\n  [class.switch]=\"orientation === 'switch'\"\r\n  #wrapper\r\n>\r\n  <div class=\"om-timeline-entries\">\r\n    @for (item of templateData(); track $index) {\r\n      <div\r\n        class=\"om-timeline-entry\"\r\n        [ngClass]=\"{\r\n        'right-side':\r\n          orientation === 'right' || (orientation === 'switch' && $index % 2 !== 0),\r\n        'left-side':\r\n          orientation === 'left' || (orientation === 'switch' && $index % 2 === 0)\r\n      }\"\r\n        #entries\r\n      >\r\n        <div class=\"om-timeline-entry-header\">\r\n          <div class=\"om-timeline-circle\">\r\n            <div class=\"om-timeline-inner-circle\"></div>\r\n          </div>\r\n          <div class=\"om-timeline-entry-title\" [innerHTML]=\"item.title\"></div>\r\n        </div>\r\n        <div class=\"om-timeline-entry-content\" [innerHTML]=\"item.content\"></div>\r\n      </div>\r\n    }\r\n\r\n    <div class=\"om-timeline-line-wrapper\">\r\n      <svg\r\n        #timelineSvg\r\n        class=\"om-timeline-svg\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        [class.d-none]=\"orientation !== 'switch'\"\r\n      >\r\n        <defs>\r\n          <linearGradient id=\"gradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n            <stop\r\n              offset=\"0%\"\r\n              style=\"stop-color: transparent; stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"10%\"\r\n              [style.stop-color]=\"gradientEnd\"\r\n              style=\"stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"90%\"\r\n              [style.stop-color]=\"gradientStart\"\r\n              style=\"stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"100%\"\r\n              style=\"stop-color: transparent; stop-opacity: 1\"\r\n            />\r\n          </linearGradient>\r\n          <linearGradient id=\"gradientBg\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\r\n            <stop\r\n              offset=\"0%\"\r\n              style=\"stop-color: transparent; stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"10%\"\r\n              [style.stop-color]=\"pathColor\"\r\n              style=\"stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"90%\"\r\n              [style.stop-color]=\"pathColor\"\r\n              style=\"stop-opacity: 1\"\r\n            />\r\n            <stop\r\n              offset=\"100%\"\r\n              style=\"stop-color: transparent; stop-opacity: 1\"\r\n            />\r\n          </linearGradient>\r\n        </defs>\r\n        <path #timelinePath class=\"om-timeline-path\"></path>\r\n        <path #timelineGradientPath class=\"om-timeline-gradient-path\"></path>\r\n      </svg>\r\n\r\n      <div\r\n        class=\"om-timeline-line\"\r\n        #timelineBackground\r\n        [class.d-none]=\"orientation === 'switch'\"\r\n      >\r\n        <div #timelineLine class=\"om-timeline-motion\"></div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n", styles: [".om-timeline{--om-timeline-entries-gap: 5rem;--om-timeline-entry-gap: 4rem;--om-timeline-entry-title-gap: 2rem;--om-timeline-entry-title-max-width: 25rem;--om-timeline-path-width: 2px;--om-timeline-gradient-start: #3b82f6;--om-timeline-gradient-end: #7f00ff;--om-timeline-path-color: #e2e8f0;width:100%}.om-timeline .om-timeline-entries{position:relative;display:flex;flex-direction:column;gap:var(--om-timeline-entries-gap);padding:10rem 0}.om-timeline .om-timeline-entries .om-timeline-entry{display:flex;justify-content:start;padding-top:20px;gap:var(--om-timeline-entry-gap)}.om-timeline.switch>.om-timeline-entries{gap:calc(var(--om-timeline-entries-gap) * 6)}.om-timeline .om-timeline-entry-header{position:sticky;top:10rem;z-index:40;display:flex;align-items:center;align-self:flex-start;gap:var(--om-timeline-entry-title-gap);width:50%;max-width:var(--om-timeline-entry-title-max-width)}.om-timeline .om-timeline-entry-header .om-timeline-circle{height:40px;width:40px;border-radius:50%;background-color:#000;display:flex;align-items:center;justify-content:center;flex-shrink:0}.om-timeline .om-timeline-entry-header .om-timeline-inner-circle{height:16px;width:16px;border-radius:50%;background-color:#262626;border:1px solid rgb(64,64,64)}.om-timeline .om-timeline-entry-content{flex:1}.om-timeline .om-timeline-line-wrapper{position:absolute;top:0;left:20px;pointer-events:none}.om-timeline .om-timeline-line-wrapper .d-none{display:none;height:0;width:0}.om-timeline .om-timeline-line-wrapper .om-timeline-line{width:var(--om-timeline-path-width);background:linear-gradient(to bottom,transparent 0%,#e2e8f0 50%,transparent 100%);-webkit-mask-image:linear-gradient(to bottom,transparent 0%,black 10%,black 90%,transparent 100%);mask-image:linear-gradient(to bottom,transparent 0%,black 10%,black 90%,transparent 100%);overflow:hidden;position:absolute;top:0;left:0;width:2px}.om-timeline .om-timeline-line-wrapper .om-timeline-motion{width:2px;background:linear-gradient(to top,#7f00ff 0%,#3b82f6 50%,transparent 100%);border-radius:50%}.om-timeline.right .om-timeline-entries .om-timeline-entry{flex-direction:row-reverse}.om-timeline.right .om-timeline-entries .om-timeline-entry .om-timeline-entry-header{flex-direction:row-reverse;justify-content:space-between}.om-timeline.right .om-timeline-line-wrapper{left:unset;right:20px}.om-timeline.switch .om-timeline-entries .om-timeline-entry.right-side,.om-timeline.switch .om-timeline-entries .om-timeline-entry.right-side .om-timeline-entry-header{flex-direction:row-reverse}.om-timeline.switch .om-timeline-entries .om-timeline-entry.left-side,.om-timeline.switch .om-timeline-entries .om-timeline-entry.left-side .om-timeline-entry-header{flex-direction:row}.om-timeline.switch .om-timeline-line-wrapper{left:20px}.om-timeline .om-timeline-path{stroke-width:var(--om-timeline-path-width);fill:none;stroke:url(#gradientBg);stroke-linecap:round;stroke-linejoin:round}.om-timeline .om-timeline-gradient-path{stroke-width:var(--om-timeline-path-width);fill:none;stroke:url(#gradient);stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:1000;stroke-dashoffset:1000;transition:stroke-dashoffset .5s ease}@media only screen and (max-width: 1000px){.om-timeline.switch>.om-timeline-entries{gap:calc(var(--om-timeline-entries-gap) * 3)}.om-timeline .om-timeline-entries .om-timeline-entry{position:relative;flex-direction:column!important}.om-timeline .om-timeline-entries .om-timeline-entry .om-timeline-entry-header{position:relative;top:0;max-width:100%;text-align:left}.om-timeline .om-timeline-entries .om-timeline-entry.left-side .om-timeline-entry-content{margin-left:70px}.om-timeline .om-timeline-entries .om-timeline-entry.left-side .om-timeline-entry-header{left:0;margin-right:auto}.om-timeline .om-timeline-entries .om-timeline-entry.right-side .om-timeline-entry-header{right:0;margin-left:auto;justify-content:space-between}.om-timeline .om-timeline-entries .om-timeline-entry.right-side .om-timeline-entry-content{margin-right:70px}}\n"] }]
        }], ctorParameters: () => [{ type: i1.DomSanitizer }, { type: i0.Renderer2 }], propDecorators: { wrapperRef: [{
                type: ViewChild,
                args: ["wrapper"]
            }], entriesList: [{
                type: ViewChildren,
                args: ["entries"]
            }], timelineBackgroundRef: [{
                type: ViewChild,
                args: ["timelineBackground"]
            }], timelineLineRef: [{
                type: ViewChild,
                args: ["timelineLine"]
            }], timelineSvgRef: [{
                type: ViewChild,
                args: ["timelineSvg"]
            }], timelinePathRef: [{
                type: ViewChild,
                args: ["timelinePath"]
            }], timelineGradientPathRef: [{
                type: ViewChild,
                args: ["timelineGradientPath"]
            }], orientation: [{
                type: Input,
                args: ["orientation"]
            }], styleClass: [{
                type: Input,
                args: ["styleClass"]
            }], entriesGap: [{
                type: Input,
                args: ["entriesGap"]
            }], entryGap: [{
                type: Input,
                args: ["entryGap"]
            }], titleGap: [{
                type: Input,
                args: ["titleGap"]
            }], pathWidth: [{
                type: Input,
                args: ["pathWidth"]
            }], titleMaxWidth: [{
                type: Input,
                args: ["titleMaxWidth"]
            }], pathColorValue: [{
                type: Input,
                args: ["pathColor"]
            }], gradientColors: [{
                type: Input,
                args: ["gradientColors"]
            }], dataValue: [{
                type: Input,
                args: ["data"]
            }] } });

/*
 * Public API Surface of ngx-timeline
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxTimelineComponent };
//# sourceMappingURL=omnedia-ngx-timeline.mjs.map
